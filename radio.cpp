#include "radio.h"

#if defined(_RETRO_)

#include <ArduinoJson.h>
#include "model.h"


// JSON_BUFFER_SIZE generated by https://arduinojson.org/assistant/
#define JSON_BUFFER_SIZE      JSON_OBJECT_SIZE(2) + 3 * JSON_OBJECT_SIZE(4) + JSON_OBJECT_SIZE(5) + 219

#define CIPHER_MAX_LENGTH     1024

byte cipher[CIPHER_MAX_LENGTH];

int encrypt_model(byte* model, size_t model_length, size_t cipher_max_length) {
	
	int cipher_length = model_length + (AES_BLOCKLEN - ((model_length - 1) & 0x10)); //  % 16));
	if (cipher_length > cipher_max_length) // cipher byte array not too big to store encrypted data
		return 0;

    struct AES_ctx ctx;

    AES_init_ctx_iv(&ctx, key, IV);
    AES_CTR_xcrypt_buffer(&ctx, (uint8_t*) cipher, cipher_length);

    return cipher_length;
}

__attribute__((__inline__)) void radio_init() {
}

void radio_send_model() {
    StaticJsonBuffer<JSON_BUFFER_SIZE>  jsonBuffer;

    String                              model = "";
    size_t                              model_len;
    size_t                              padd_len;
    size_t                              num_blocks;
    size_t                              cipher_len;
    
    JsonObject&   root = jsonBuffer.createObject();

    JsonObject& pedals = root.createNestedObject("pedals");
    JsonObject& suspensions = root.createNestedObject("suspensions");
    JsonObject& wheels = root.createNestedObject("wheels");
    JsonObject& accelerometers = root.createNestedObject("accelerometers");

    pedals["tps1"] = tps1_percentage;
    pedals["tps2"] = tps1_percentage;
    pedals["brake"] = brake_percentage;
    pedals["apps_plaus"] = apps_plausibility;
    pedals["brake_plaus"] = brake_plausibility;

    suspensions["front_sx"] = fr_sx_susp;
    suspensions["front_dx"] = fr_dx_susp;
    suspensions["retro_sx"] = rt_sx_susp;
    suspensions["retro_dx"] = rt_dx_susp;

    wheels["front_sx"] = get_fr_sx_rpm();
    wheels["front_dx"] = get_fr_dx_rpm();
    wheels["retro_sx"] = get_rt_sx_rpm();
    wheels["retro_dx"] = get_rt_dx_rpm();

    accelerometers["acc_x"] = acc_x_value;
    accelerometers["acc_z"] = acc_z_value;

    root.printTo(model);

    model_len = model.length();
    strncpy((char*) cipher, model.c_str(), model_len);

    num_blocks = model_len / AES_BLOCKLEN;
    padd_len = model_len % AES_BLOCKLEN;

    memset(cipher + model_len, padd_len, padd_len);
  
    if (!(cipher_len = encrypt_model(cipher, model_len, CIPHER_MAX_LENGTH)))
        return;   // error: string too long

  


    //SPI_send_string(log);
}

#endif