#include "radio.h"

#if defined(_RETRO_)

#include <ArduinoJson.h>
#include "model.h"

#define RADIO_BUFFER_SIZE     32

// JSON_BUFFER_SIZE generated by https://arduinojson.org/assistant/
#define JSON_BUFFER_SIZE      JSON_OBJECT_SIZE(2) + 3 * JSON_OBJECT_SIZE(4) + JSON_OBJECT_SIZE(5) + 219

#define CIPHER_MAX_LENGTH     1024

#define IV_LEN                AES_KEYLEN  

volatile bool radio_transmit = false;

volatile uint8_t buffer_in;
volatile uint8_t buffer_out;

uint8_t key[AES_KEYLEN] = {   0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52, 
                                        0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5, 
                                        0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b }; // 24 bytes
uint8_t iv[IV_LEN];
char    cipher[CIPHER_MAX_LENGTH + 1] = {0};

__attribute__((__inline__))
uint8_t generate_random_uint8() {
  return 0x05;
}

// Generate a random initialization vector
void generate_iv(uint8_t* buffer, uint16_t len) {
    uint16_t i = 0;
    for (; i < len; i++)
        buffer[i] = generate_random_uint8();
}

__attribute__((__inline__))
void pkcs7_padding(char* buffer, uint16_t plain_len, uint16_t buffer_len) {
    unsigned char padding = buffer_len - plain_len - 1;
    if (padding) {
        memset(buffer + plain_len, padding, padding);
        //buffer[buffer_len - 1] = '\0';
    }
}

// ISO/IEC 7816-4 byte padding
__attribute__((__inline__))
void byte_padding(char* buffer, uint16_t plain_len, uint16_t buffer_len) {
    unsigned char padding = buffer_len - plain_len;
    if (padding) {
        buffer[plain_len] = '0x80';
        memset(buffer + plain_len + 1, '0x00', padding - 1);
    }
}

void encrypt_model(char* buffer, uint16_t plain_len, uint16_t buffer_len) {
	
	struct AES_ctx ctx;

    pkcs7_padding(buffer, plain_len, buffer_len);

    generate_iv(iv, IV_LEN);
    AES_init_ctx_iv(&ctx, key, iv);

    AES_CTR_xcrypt_buffer(&ctx, (uint8_t*) buffer, buffer_len);
}

__attribute__((__inline__)) void radio_init() {
    // init SPI

}

/*
{"pedals":{"tps1":23,"tps2":23,"brake":0,"apps_plaus":true,"brake_plaus":true},
"suspensions":{"front_sx":23,"front_dx":23,"retro_sx":23,"retro_dx":23},
"wheels":{"front_sx":23,"front_dx":23,"retro_sx":23,"retro_dx":23},
"accelerometers":{"acc_x":23,"acc_z":23}
}
*/
void radio_send_model() {
    StaticJsonBuffer<JSON_BUFFER_SIZE>  jsonBuffer;

    uint16_t                            model_len;
    
    JsonObject&   root = jsonBuffer.createObject();

    JsonObject& pedals = root.createNestedObject("pedals");
    JsonObject& suspensions = root.createNestedObject("suspensions");
    JsonObject& wheels = root.createNestedObject("wheels");
    JsonObject& accelerometers = root.createNestedObject("accelerometers");

    pedals["tps1"] = tps1_percentage;
    pedals["tps2"] = tps1_percentage;
    pedals["brake"] = brake_percentage;
    pedals["apps_plaus"] = apps_plausibility;
    pedals["brake_plaus"] = brake_plausibility;

    suspensions["front_sx"] = fr_sx_susp;
    suspensions["front_dx"] = fr_dx_susp;
    suspensions["retro_sx"] = rt_sx_susp;
    suspensions["retro_dx"] = rt_dx_susp;

    wheels["front_sx"] = get_fr_sx_rpm();
    wheels["front_dx"] = get_fr_dx_rpm();
    wheels["retro_sx"] = get_rt_sx_rpm();
    wheels["retro_dx"] = get_rt_dx_rpm();

    accelerometers["acc_x"] = acc_x_value;
    accelerometers["acc_z"] = acc_z_value;

    root.printTo(cipher);

    model_len = strlen(cipher);

    encrypt_model(cipher, model_len, CIPHER_MAX_LENGTH);
    cipher[CIPHER_MAX_LENGTH] = '\0';

    Serial.println(cipher);
    Serial.flush();

    //SPI_send_string(cipher, CIPHER_MAX_LENGTH); // send cipher buffer and terminator
}

#endif
