/** 
 *  @file           radio.cpp
 *  @author         Arella Matteo <br/>
 *                  (mail: arella.1646983@studenti.uniroma1.it)
 *  @date           2018
 *  @brief          Radio implementation file
 */

#include "radio.h"

#if defined(_RETRO_)

#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>
#include <Arduino.h> // _DSB()
#include <ArduinoJson.h>
#include <Base64.h>

#include "sensors_pinout.h"
#include "model.h"

/**
 *  @addtogroup Radio_module Radio module
 *   @{
 */

/**
 *  @def CTR
 *  @brief Enable/Disable aes CTR mode
 */
#define CTR 1

#include "aes.h"

/**
 *  @def RADIO_KEY_BITS
 *  @brief Aes key length [\f$bits\f$]
 */
#define RADIO_KEY_BITS  192 // choose 128, 192 or 256

/* 

*/
// JSON_BUFFER_SIZE generated by https://arduinojson.org/assistant/
/**
 *  @def JSON_BUFFER_SIZE
 *  @brief Size of static buffer for JSON serialization, generated by https://arduinojson.org/assistant/.
 *         Model serialization format:
 *         @code
 *         {"pedals":{"tps1":XX,"tps2":XX,"brake":XX,"apps_plaus":true,"brake_plaus":true},
 *          "suspensions":{"front_sx":XX,"front_dx":XX,"retro_sx":XX,"retro_dx":XX},
 *          "wheels":{"front_sx":XXXX,"front_dx":XXXX,"retro_sx":XXXX,"retro_dx":XXXX},
 *          "accelerometers":{"acc_x":X,"acc_z":X}}
 *         @endcode
 */
#define JSON_BUFFER_SIZE      JSON_OBJECT_SIZE(2) + 3 * JSON_OBJECT_SIZE(4) + JSON_OBJECT_SIZE(5) + 219

/**
 *  @def CIPHER_MAX_LENGTH
 *  @brief Cipher buffer max length (according to https://arduinojson.org/assistant/).
 *  @warning Must be a multiple of 16.
 */
#define CIPHER_MAX_LENGTH     1024 // multiplo di 16

/**
 *  @def IV_LEN
 *  @brief Initialization Vector length
 */
#define IV_LEN                AES_KEYLEN  

/**
 *  @var volatile bool radio_transmit;
 *  @brief Radio transmit enable flag
 */
volatile bool radio_transmit = false;

#ifdef __DOXYGEN__
/**
 *  @var char key[AES_KEYLEN]
 *  @brief AES encryption KEY.
 */
char key[AES_KEYLEN];
#else
char key[AES_KEYLEN] = {   0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52, 
                                        0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5, 
                                        0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b }; // 24 bytes
#endif

/**
 *  @var char iv[IV_LEN + 1]
 *  @brief AES encryption Initialization Vector.
 *  @warning IV must never be reused with the same key
 */
char iv[IV_LEN + 1];

/**
 *  @var cipher[CIPHER_MAX_LENGTH + 1]
 *  @brief Encrypted model buffer
 */
char cipher[CIPHER_MAX_LENGTH + 1] = {0};

/**
 *  @var RF24 radio(RADIO_CE_PIN, RADIO_CSN_PIN)
 *  @brief Radio
 */
RF24 radio(RADIO_CE_PIN, RADIO_CSN_PIN);

/** 
 *  @var const uint64_t pipe;
 *  @brief Radio writing pipe
 */
const uint64_t pipe = 0xE8E8F0F0E1LL;

/**
 *  @brief      Encrypt model for transmit over radio.
 *  
 *  @author     Arella Matteo <br/>
 *                  (mail: arella.1646983@studenti.uniroma1.it)
 *
 *  @param[in,out] buffer     - Buffer to be encrypted
 *  @param[in]     iv         - Initialisation vector for AES encryption
 *  @param[in]     plain_len  - Plain model's length
 *  @param[in]     buffer_len - Buffer length
 */
void encrypt_model(char* buffer, char* iv, uint16_t plain_len, uint16_t buffer_len);

/**
 *  @brief      Generate a Cryptgraphically secure pseudorandom number from TRNG
 *              hardware peripheral.
 *  
 *  @author     Arella Matteo <br/>
 *                  (mail: arella.1646983@studenti.uniroma1.it)
 *
 *  @return     Cryptgraphically secure pseudorandom number.
 */
__attribute__((__inline__))
volatile char generate_random_char() {
    while (!(TRNG->TRNG_ISR & TRNG_ISR_DATRDY));
    return (volatile char) TRNG->TRNG_ODATA;
}

/**
 *  @brief      Generate a randomized initialization vector.
 *  
 *  @author     Arella Matteo <br/>
 *                  (mail: arella.1646983@studenti.uniroma1.it)
 *
 *  @param[out]    buffer   - Initialisation Vector
 *  @param[in]     len      - Buffer length
 */
void generate_iv(char* buffer, uint16_t len) {
    uint16_t i = 0;
    for (; i < len; i++)
        buffer[i] = generate_random_char();
}

/**
 *  @brief      Perform PKCS7 padding described in RFC 5652.
 *  
 *  @author     Arella Matteo <br/>
 *                  (mail: arella.1646983@studenti.uniroma1.it)
 *
 *  @param[out]    buffer       - Buffer
 *  @param[in]     plain_len    - Plain model's length
 *  @param[in]     buffer_len   - Buffer length
 */
__attribute__((__inline__))
void pkcs7_padding(char* buffer, uint16_t plain_len, uint16_t buffer_len) {
    unsigned char padding = buffer_len - plain_len;
    memset(buffer + plain_len, padding, padding);
}

/**
 *  @brief      Perform ISO/IEC 7816-4 byte padding.
 *  
 *  @author     Arella Matteo <br/>
 *                  (mail: arella.1646983@studenti.uniroma1.it)
 *
 *  @param[out]    buffer       - Buffer
 *  @param[in]     plain_len    - Plain model's length
 *  @param[in]     buffer_len   - Buffer length
 */
__attribute__((__inline__))
void byte_padding(char* buffer, uint16_t plain_len, uint16_t buffer_len) {
    unsigned char padding = buffer_len - plain_len;
    if (padding) {
        buffer[plain_len] = '0x80';
        memset(buffer + plain_len + 1, '0x00', padding - 1);
    }
}

void encrypt_model(char* buffer, char* iv, uint16_t plain_len, uint16_t buffer_len) {
	
	struct AES_ctx ctx;

    //byte_padding(buffer, plain_len, buffer_len);

    AES_init_ctx_iv(&ctx, (const uint8_t*) key, (const uint8_t*) iv);

    AES_CTR_xcrypt_buffer(&ctx, (uint8_t*) buffer, buffer_len);
}

/**
 *  @brief      Initialize TRNG (True Random Number Generator) hardware peripheral
 *              as a CSPRNG (Cryptographically Secure Pseudo-Random Number Generator)
 *              for generate randomized IV.
 *  
 *  @author     Arella Matteo <br/>
 *                  (mail: arella.1646983@studenti.uniroma1.it)
 */
__attribute__((__inline__))
void radio_init() {
    pmc_enable_periph_clk(ID_TRNG);
    TRNG->TRNG_IDR = 0xFFFFFFFF;
    TRNG->TRNG_CR = TRNG_CR_KEY(0x524e47) | TRNG_CR_ENABLE;

    // init radio
    radio.begin();
    radio.openWritingPipe(pipe);
    radio.stopListening();
}

/**
 *  @brief      Actions performed involve:
 *              -   serialize vehicle data into static JSON buffer;
 *              -   generate randomised IV;
 *              -   add padding to buffer;
 *              -   encrypt model with 192-bit AES encryption (CTR mode);
 *              -   encode buffer with base64 encoding;
 *              -   send buffer over radio.
 *  
 *  @author     Arella Matteo <br/>
 *                  (mail: arella.1646983@studenti.uniroma1.it)
 */
void radio_send_model() {
    StaticJsonBuffer<JSON_BUFFER_SIZE>  jsonBuffer;

    uint16_t                            model_len;
    
    JsonObject&   root = jsonBuffer.createObject();

    JsonObject& pedals = root.createNestedObject("pedals");
    JsonObject& suspensions = root.createNestedObject("suspensions");
    JsonObject& wheels = root.createNestedObject("wheels");
    JsonObject& accelerometers = root.createNestedObject("accelerometers");

    pedals["tps1"] = tps1_percentage;
    pedals["tps2"] = tps2_percentage;
    pedals["brake"] = brake_percentage;
    pedals["apps_plaus"] = apps_plausibility;
    pedals["brake_plaus"] = brake_plausibility;

    suspensions["front_sx"] = fr_sx_susp;
    suspensions["front_dx"] = fr_dx_susp;
    suspensions["retro_sx"] = rt_sx_susp;
    suspensions["retro_dx"] = rt_dx_susp;

    // Data Synchronization Barrier 
    // ensures all explicit data transfers before the DSB are complete before 
    // any instruction after the DSB is executed.
    __DSB(); 
    wheels["front_sx"] = get_fr_sx_rpm();

    __DSB();
    wheels["front_dx"] = get_fr_dx_rpm();

    __DSB();
    wheels["retro_sx"] = get_rt_sx_rpm();

    __DSB();
    wheels["retro_dx"] = get_rt_dx_rpm();

    accelerometers["acc_x"] = acc_x_value;
    accelerometers["acc_z"] = acc_z_value;

    memset(cipher, 0, CIPHER_MAX_LENGTH);
    root.printTo(cipher);

    model_len = strlen(cipher);

    generate_iv(iv, IV_LEN);
    iv[IV_LEN] = '\0';

    pkcs7_padding(cipher, model_len, CIPHER_MAX_LENGTH);
    encrypt_model(cipher, iv, model_len, CIPHER_MAX_LENGTH);

    int encodedIvLength = Base64.encodedLength(IV_LEN);
    int encodedLength = Base64.encodedLength(CIPHER_MAX_LENGTH);
    char encodedString[encodedIvLength + encodedLength];

    Base64.encode(encodedString, iv, IV_LEN);
    Base64.encode(encodedString + encodedIvLength, cipher, CIPHER_MAX_LENGTH);

    radio.write(encodedString, encodedIvLength + encodedLength);
}

#endif

/**
 *  @}
 */